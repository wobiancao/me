{"meta":{"title":"兔子吃过窝边草","subtitle":"一个菜鸡Android开发","description":"没有代码可以码我快死了","author":"兔子吃过窝边草","url":"http://www.jianshu.com/u/114bbbfb977f"},"pages":[{"title":"关于我","date":"2017-04-15T02:12:36.000Z","updated":"2017-04-15T02:12:03.000Z","comments":true,"path":"about/index.html","permalink":"http://www.jianshu.com/u/114bbbfb977f/about/index.html","excerpt":"","text":"天造之才，皆有其用 燕雀安知鸿鹄之志人固有一死，反正会死。 你好我在成都 我的简书：http://www.jianshu.com/u/114bbbfb977f我的github: https://github.com/wobiancao我的邮箱：420245103@qq.com"}],"posts":[{"title":"Android 软键盘和emoji表情切换方案，和微信几乎一样的体验","slug":"Android 软键盘和emoji表情切换方案","date":"2017-04-14T07:30:43.000Z","updated":"2017-04-14T07:33:20.000Z","comments":true,"path":"2017/04/14/Android 软键盘和emoji表情切换方案/","link":"","permalink":"http://www.jianshu.com/u/114bbbfb977f/2017/04/14/Android 软键盘和emoji表情切换方案/","excerpt":"","text":"注意：本项目还有一个小坑。第一次进去的时候有时候输入框没有得到焦点，没有弹出软键盘，所以不能更好的量取软键盘高度，给了一个默认值787 软键盘默认高度。所以可以忽略不计，一旦弹出了软键盘，这个高度就被记录下来了，存在本地，以便下一次用。这几天没事，想到之前做im聊天的时候，表情输入和键盘之间的切换体验有些问题，看了微信的，觉得真好，就有了想描摹一下的心思，所有有了这个demo。站在巨人的肩膀上，我们才能走得更远。一些配置,导入相关的库：1234567891011121314151617dependencies &#123;compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])testCompile &apos;junit:junit:4.12&apos;compile project(&apos;:library&apos;)compile &apos;com.android.support:appcompat-v7:23.1.1&apos;compile &apos;com.android.support:design:23.1.1&apos;compile &apos;com.jakewharton:butterknife:7.0.1&apos;//butterknife注解框架compile &apos;com.android.support:support-v4:23.1.1&apos;&#125; 键盘弹出方案1android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; 提一下emoji表情输入，其实很简单。123456789101112131415调用两个接口EmojiconGridFragment.OnEmojiconClickedListener//点击表情接口EmojiconsFragment.OnEmojiconBackspaceClickedListener//删除表情接口然后实现一下方法，emoji就好了@Override public void onEmojiconBackspaceClicked(View v) &#123; EmojiconsFragment.backspace(emojiEditTextView); &#125; @Override public void onEmojiconClicked(Emojicon emojicon) &#123; EmojiconsFragment.input(emojiEditTextView, emojicon); &#125; 在运用前，要知道这个公式：KeyBoard_H = Screen_H - StatusBar_H - AppRect_H软键盘高度 = 分辨率高 - 状态栏高 - 应用可视高于是有了这个方法12345678910public static int getKeyboardHeight(Activity paramActivity) &#123; int height = SystemUtils.getScreenHeight(paramActivity) - SystemUtils.getStatusBarHeight(paramActivity) - SystemUtils.getAppHeight(paramActivity); if (height == 0) &#123; height = SharedPreferencesUtils.getIntShareData(&quot;KeyboardHeight&quot;, 787);//787为默认软键盘高度 基本差不离 &#125;else&#123; SharedPreferencesUtils.putIntShareData(&quot;KeyboardHeight&quot;, height); &#125; return height; &#125; 主页布局文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:emojicon=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; tools:context=&quot;com.wobiancao.keyboarddemo.MainActivity&quot; tools:showIn=&quot;@layout/activity_main&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/emojicons_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.rockerhieu.emojicon.EmojiconEditText android:id=&quot;@+id/emojicons_edit&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;left|top&quot; android:padding=&quot;8dp&quot; android:textSize=&quot;18sp&quot; emojicon:emojiconSize=&quot;18sp&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;?attr/colorPrimary&quot; android:gravity=&quot;center&quot;&gt; &lt;ImageView android:id=&quot;@+id/emojicons_icon&quot; android:layout_width=&quot;40dip&quot; android:layout_height=&quot;40dip&quot; android:padding=&quot;8dip&quot; android:src=&quot;@mipmap/ic_emoticon&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;RelativeLayout android:id=&quot;@+id/emojicons_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot;&gt;&lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 剩下略提一下软键盘和输入框的切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 @OnClick(&#123;R.id.emojicons_icon, R.id.emojicons_edit&#125;) void onClick(View view) &#123; switch (view.getId())&#123; case R.id.emojicons_icon://点击表情图标,如果表情显示，隐藏表情，打开软键盘。反之，显示表情，隐藏键盘 if (emojiconsLayout.isShown()) &#123; hideEmotionView(true); &#125; else &#123; showEmotionView(SystemUtils.isKeyBoardShow(this)); &#125; break; case R.id.emojicons_edit://点击输入框，打开软键盘，隐藏表情 hideEmotionView(true); break; default: break; &#125; &#125;/** * 隐藏emoji **/ private void hideEmotionView(boolean showKeyBoard) &#123; if (emojiconsLayout.isShown()) &#123; if (showKeyBoard) &#123; LinearLayout.LayoutParams localLayoutParams = (LinearLayout.LayoutParams) emojiconsContainer.getLayoutParams(); localLayoutParams.height = emojiconsLayout.getTop(); localLayoutParams.weight = 0.0F; emojiconsLayout.setVisibility(View.GONE); getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE); SystemUtils.showKeyBoard(editEmojicon); editEmojicon.postDelayed(new Runnable() &#123; @Override public void run() &#123; unlockContainerHeightDelayed(); &#125; &#125;, 200L); &#125; else &#123; emojiconsLayout.setVisibility(View.GONE); getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE); unlockContainerHeightDelayed(); &#125; &#125; &#125; private void showEmotionView(boolean showAnimation) &#123; if (showAnimation) &#123; transitioner.setDuration(200); &#125; else &#123; transitioner.setDuration(0); &#125; emotionHeight = SystemUtils.getKeyboardHeight(this); SystemUtils.hideSoftInput(editEmojicon); emojiconsLayout.getLayoutParams().height = emotionHeight; emojiconsLayout.setVisibility(View.VISIBLE); getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN); //在5.0有navigationbar的手机，高度高了一个statusBar int lockHeight = SystemUtils.getAppContentHeight(this); lockContainerHeight(lockHeight); &#125; 然后demo里面用到了开源emoji项目，贴上开源地址，表示感谢 emoji表情开源：https://github.com/rockerhieu/emojicon本demo开源地址 ：https://github.com/a12a15a05/KeyBoardDemo demo apk地址： 有bug或问题，欢迎探讨，谢谢","categories":[],"tags":[]},{"title":"Android Studio一步步教你集成发布适配","slug":"Android Studio一步步教你集成发布适配","date":"2017-04-14T07:30:43.000Z","updated":"2017-04-14T08:03:00.000Z","comments":true,"path":"2017/04/14/Android Studio一步步教你集成发布适配/","link":"","permalink":"http://www.jianshu.com/u/114bbbfb977f/2017/04/14/Android Studio一步步教你集成发布适配/","excerpt":"","text":"开门见山，本章教你如何配置多渠道一键打包，本教程只符合使用Android Studio的童鞋1.首先检查本地gradle版本是否是最新的，我建议换成最新的编译版本gradle版本查看我用的是gradle-2.10-all 123用迅雷下载更快https://downloads.gradle.org/distributions/gradle-2.10-all.zip下载其它版本把“2.10”替换成你所需要的版本号就ok啦 点击可下载下载后解压到任意你所指定的文件夹2.最后给你的工程指定gradle版本位置，使用本地的，如图所示 3.我相信java环境都已经配置好了，所以无需再提。本教程并没有去木有配置gradle的环境变量，因为–没用到，至于gradle环境变量配置教程，有需要的童鞋可以看一下 环境变量配置错误，出现问题找我，我也不会认的0 - 0因为本教程，木有去配置gradle环境，木有去配置gradle环境，重要事情说三遍 (gradle环境变量配置)1234567891011WIN下环境变量添加方法:我的电脑→属性→高级系统属性设置→高级→环境变量，先新建一个用户变量GRADLE_HOME填入你上面解压知道的文件夹路径，之后在系统PATH变量下添加GRADLE_HOME/bin;确定保存即可，重启命令行，然后运行gradle -version查看当前gradle的版本号. MAC下添加环境变量:$ vim .bash_profile export GRADLE_HOME=/Applications/gradle-2.3;export PATH=$PATH:$GRADLE_HOME/bin检查是否成功$ gradle -version 开始我们的配置1.首先是友盟渠道，相信很多公司产品都融入了这个把UMENG_CHANNEL下面的值改为 ${UMENG_CHANNEL_VALUE}123&lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot; /&gt; 然后打开app目录下的build.gradle文件配置渠道1234567891011productFlavors &#123; abc &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;abc&quot;] &#125; baiduyun &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;baiduyun&quot;] &#125; wandoujia &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wandoujia&quot;] &#125; &#125; 2.多渠道配置结束，就是这么简单，然后我们打包的时候肯定都希望能够区分每一个包是哪个渠道的，添加下面的代码可以实现1234567891011121314151617181920buildTypes &#123; release &#123; minifyEnabled true//是否混淆 zipAlignEnabled true shrinkResources true//移除未使用的资源文件 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; if (output.outputFile != null &amp;&amp; output.outputFile.name.endsWith(&apos;.apk&apos;)) &#123; File outputDirectory = new File(outputFile.parent); def fileName if (variant.buildType.name == &quot;release&quot;) &#123; fileName = &quot;appName_v$&#123;defaultConfig.versionName&#125;_$&#123;packageTime()&#125;_$&#123;variant.productFlavors[0].name&#125;.apk&quot; &#125; else &#123; fileName = &quot;appName_v$&#123;defaultConfig.versionName&#125;_$&#123;packageTime()&#125;_beta.apk&quot;&#125;output.outputFile = new File(outputDirectory, fileName) &#125; &#125; &#125;&#125;&#125; 然后点击 Sync Now然后报错了是吧？恩，packageTime()这个方法都还没给你,放在顶部即可123def packageTime() &#123; return new Date().format(&quot;yyyy-MM-dd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))&#125; 3.Sync Now然后按照下面步骤打包吧12345Build-&gt;Clean ProjectBuild-&gt;Rebuild ProjectBuild-&gt;Generate Singned APK...-&gt;next配置你的签名配置-&gt;next 解释在下图-&gt;finish 完了就会在文件夹看到你需要的包了 自定义配置文件1.多个自动升级sdk的时候比如想把包放入360和百度的时候，呵呵，大家都懂的，360是最近才开始必须接入他的升级sdk才能上架的。这里就不吐槽了，公司要求要去上架这些应用商城。打一次包就能搞定这些接入问题，因为我一开始接入的是友盟自动升级，需求的增加就越来越多，ok开始配置：先来做个假设：假设上面的abc包是360升级的，wandoujia是友盟升级的，baiduyun是百度升级的定义一个名字为AUTO_TYPE的String类型常量 默认值为umeng放在defaultConfig里面123 defaultConfig &#123; buildConfigField &quot;String&quot;, &quot;AUTO_TYPE&quot;, &quot;umeng&quot;&#125; 2.然后配置渠道包123456789101112131415productFlavors &#123; abc &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;abc&quot;] buildConfigField &quot;String&quot;, &quot;AUTO_TYPE&quot;, &quot;360&quot; &#125; wandoujia &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wandoujia&quot;] buildConfigField &quot;String&quot;, &quot;AUTO_TYPE&quot;, &quot;umeng&quot; &#125; baiduyun &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;baiduyun&quot;] buildConfigField &quot;String&quot;, &quot;AUTO_TYPE&quot;, &quot;baiduyun&quot; &#125; &#125; next12Build-&gt;Clean ProjectBuild-&gt;Rebuild Project 3.看看是否生成了这个文件文件夹名是根据你productFlavors下面最后一个渠道名生成的 生成了我们想要的文件，就可以运用了12345678910if (ConstantField.AUTO_TYPE_BAIDU.equals(BuildConfig.AUTO_TYPE))&#123; BDAutoUpdateSDK.silenceUpdateAction(this);//百度静默更新 L.e(TAG,&quot;baidu更新&quot;); &#125;else if(ConstantField.AUTO_TYPE_360.equals(BuildConfig.AUTO_TYPE))&#123; UpdateManager.checkUpdate(this); L.e(TAG,&quot;360更新&quot;); &#125;else&#123; UmengUpdateAgent.update(this); L.e(TAG,&quot;umeng更新&quot;);&#125; 添加是否打印log这个就无需再说了吧，方法类似，把string改成boolean即可放两个所学习到的文章转载注明来源即可美团Android自动化之旅—适配渠道包美团Android自动化之旅—生成渠道包","categories":[],"tags":[]},{"title":"猴赛雷抢红包插件App","slug":"猴赛雷抢红包插件App","date":"2017-04-14T07:30:43.000Z","updated":"2017-04-14T08:04:05.000Z","comments":true,"path":"2017/04/14/猴赛雷抢红包插件App/","link":"","permalink":"http://www.jianshu.com/u/114bbbfb977f/2017/04/14/猴赛雷抢红包插件App/","excerpt":"","text":"世上没有什么是一颗猴赛雷不能解决的，如果有，那就两颗 代码重构了，结构更清晰，微信抢红包代码和qq抢红包代码分离，能够更好的学习 这个app就是自己玩玩，代码就在那儿，能抢微信和qq的红包，不做商用，学习的开源代码233，最近抢红包比较火，又不敢用别人做的，所以还是自己做了一个。加了友盟更新，其它什么都没了。先看截图 本项目开源地址https://github.com/wobiancao/GetLuckyMomenyEasy本项目支持QQ红包和微信红包哟学习的开源的地址：https://github.com/geeeeeeeeek/WeChatLuckyMoney微信抢红包插件, 帮助你在微信群聊抢红包时战无不胜. An Android app that helps you snatch virtual red envelopes in WeChat group chat.试用地址：http://pre.im/housailei豌豆荚地址：http://www.wandoujia.com/apps/com.wobiancao.getluckymomenyeasy扫描二维码可下载PP助手下载 http://m.pp.cn/detail.html?appid=6762766&amp;ch_src=pp_dev&amp;ch=default注：本demo只是学习之用，商用请自行承担责任。ps：红包抢到多了，不介意发点给我附上本人支付宝，抢得多的，不介意可以来一点^ - ^","categories":[],"tags":[]},{"title":"我新建Android工程需要的开源项目","slug":"我新建Android工程需要的开源项目","date":"2017-04-14T07:30:43.000Z","updated":"2017-04-14T08:04:35.000Z","comments":true,"path":"2017/04/14/我新建Android工程需要的开源项目/","link":"","permalink":"http://www.jianshu.com/u/114bbbfb977f/2017/04/14/我新建Android工程需要的开源项目/","excerpt":"","text":"网络框架 retrofit 结合okhttp Retrofit很有创意的一款开源网络框架，让用户自定义接口，并使用其提供的注解，对接口进行解析和调用，是Square旗下的产品之一;动态代理和反射。其实Retrofit无非就是让用户创建接口，使用自己指定的规则进行网络访问，把接口传入Retrofit，接口上附着的规则由Retrofit进行层层解析后，再进行实际的网络调用。Retrofit所做的事情就是帮助用户简化了大量的网络访问代码，用户只需写少量代码就能得到想要的结果。 开源地址：https://github.com/square/retrofit 学习地址： http://zijianwang.xyz/blog/Android-Dev-The-simple-user-of-Retrofit-Http-Client/ 事件总线框架 eventBus Otto事件总线框架 原理解析 主要功能是帮助我们来降低多个类之间的耦合度的（解耦），\b都需要注册和反注册 eventBus: 1、找到被注册者中所有的订阅方法。 2、依次遍历订阅方法，找到EventBus中eventType对应的订阅列表，然后根据当前订阅者和订阅方法创建一个新的订阅加入到订阅列表 3、找到EvnetBus中subscriber订阅的事件列表，将eventType加入到这个事件列表。 开源地址：https://github.com/greenrobot/EventBus 学习地址：http://blog.csdn.net/harvic880925/article/details/40660137 otto： @Subscribe 订阅事件，也就是事件的处理者，它有且仅有一个参数YourEvent，每一个Subscribe对应处理一个YourEvent。Event用于连接（匹配）post和订阅。 @Produce 产生事件，改方法在对象被register后即被调用（–使用情况比较特殊的），该方法必须有一个非空的返回值，参数必须为空。 bus.post(new YourEvent(…)),发送一个事件，等待@Subcribe处理 开源地址：https://github.com/square/otto 应用模式 mvp mvc mvvm 根据项目大小选择模式，大型项目推荐使用mvp模式，便于维护不解释，小型的应用用mvp会增加更多的时间，所以可以选择mvc，至于Android的mvvm大家可以先去了解，有兴趣可以做一做。 响应式编程框架RxJava 采用观察者设计模式,这个新鲜的东西强大又好用，至于教程大家可以看看这个 学习地址：http://gank.io/post/560e15be2dca930e00da1083写得很详细 数据存储Realm Realm，为移动设备而生，替代SQLite和Core Data。为你省下数周的时间和数千行的代码，帮你创造出更棒的用户体验。 主页：https://realm.io/cn/ 下拉刷新控件 谁能想到，下拉刷新本来用原生的就很好，然而你们的ui设计会让你如愿吗？ 推荐一个下拉刷新控件：https://github.com/Aspsine/SwipeToLoadLayout 目前性能最好的下拉刷新 https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh 这些东西，构建一个基础应用已经够了，当然可以根据自己的爱好来换，我只是一个搬运工，不过，我推荐这些，都是我用在实际项目中的东西，好用才推荐！","categories":[],"tags":[]},{"title":"Android Studio ndk-Jni开发详细入门,Aes加密demo","slug":"Android Studio ndk-Jni开发详细入门,Aes加密demo","date":"2017-04-14T07:30:43.000Z","updated":"2017-04-14T08:04:57.000Z","comments":true,"path":"2017/04/14/Android Studio ndk-Jni开发详细入门,Aes加密demo/","link":"","permalink":"http://www.jianshu.com/u/114bbbfb977f/2017/04/14/Android Studio ndk-Jni开发详细入门,Aes加密demo/","excerpt":"","text":"Java Native Interface (JNI)标准是java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI 是本地编程接口，它使得在 Java 虚拟机 (VM) 内部运行的 Java 代码能够与用其它编程语言(如 C、C++ 和汇编语言)编写的应用程序和库进行交互操作。 由于Android的应用层的类都是以Java写的，这些Java类编译为Dex型式的Bytecode之后，必须靠Dalvik虚拟机(VM: Virtual Machine)来执行。VM在Android平台里，扮演很重要的角色。 （多的咱不说了,介绍什么的 到处都有可以去搜一下）咱们先建一个NdkJniDemo的工程 新建JniUtils类实现native方法123public class JniUtils &#123; public static native String getStringFormC();&#125; 然后clean project 再rebuild project 生成class文件，这时候打开如下图的文件夹看是否生成了classes文件夹，没有生成请重新来过。再打开Terminal输入指令cd app/build/intermediates/classes/debug然后再输入指令javah -jni com.wobiancao.ndkjnidemo.ndk.JniUtils注意 这里javah -jni后面跟的是JniUtils类的全路径，如果javah报不存在之类的，是你的java环境没有配置好。 这时候打开classes/debug下面的文件发现多了一个文件com_wobiancao_ndkjnidemo_ndk_JniUtils.h然后在src/main下新建文件夹jni,把生成的.h文件复制或者剪切到jni文件夹下面去，新建一个c类随便取一个名字，添加代码如下12345678910//// Created by XY on 16/1/4.//#include &quot;com_wobiancao_ndkjnidemo_ndk_JniUtils.h&quot;/* * Class: Java_com_wobiancao_ndkjnidemo_ndk_JniUtils * Method: getStringFormC * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_wobiancao_ndkjnidemo_ndk_JniUtils_getStringFormC (JNIEnv *env, jobject obj)&#123; return (*env)-&gt;NewStringUTF(env,&quot;这里是来自c的string&quot;); 这里发现头文件#include &lt;jni.h&gt;报红色，是因为咱们还没有配置ndk环境，打开file-&gt;project structure选择你所下载的ndk环境路径，如果没有ndk这里有个地址大家可以去下载 一个安卓工具集合的网站：http://androiddevtools.cn/ 设置好了之后，发现头文件还是红色的，然后再build一下工程，就会有提示 Error: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental. Set “android.useDeprecatedNdk=true” in gradle.properties to continue using the current NDK integration. 按着提示做就行了 在gradle.properties文件末尾添加android.useDeprecatedNdk=true就ok啦然后在app文件下得build.gradle -&gt;defaultConfig括号内添加如下代码123ndk &#123; moduleName &quot;NdkJniDemo&quot; //生成的so名字 abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; //输出指定三种abi体系结构下的so库，目前可有可无。&#125; 到了这一步重新build项目，发现已经没有变红了。接下来就是运用了，在JniUtils类里面添加如下代码123static &#123; System.loadLibrary(&quot;NdkJniDemo&quot;);//之前在build.gradle里面设置的so名字，必须一致&#125; 然后简单调用就行了,MainActivity代码如下123456789public class MainActivity extends AppCompatActivity &#123; TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.ndk_text); textView.setText(JniUtils.getStringFormC()); &#125;&#125; 运行结果如图 咱们打开app-&gt;intermediates-ndk-debug发现生成了三个文件夹，并且对应了之前我们在build.gradle配置的abiFilters大功告成。新建libs文件夹把这三个文件夹放进去然后删除咱们的jni文件试试，是否工程还能运用？ok 教程完毕最后出一个利用jni的Aes加密demo运行结果如图所示 项目地址：https://github.com/a12a15a05/NdkJniDemo谢谢star欢迎点赞=。=转载请注明来源","categories":[],"tags":[]},{"title":"Android 开发最佳实践","slug":"Android 开发最佳实践","date":"2017-04-14T07:30:43.000Z","updated":"2017-04-14T08:05:27.000Z","comments":true,"path":"2017/04/14/Android 开发最佳实践/","link":"","permalink":"http://www.jianshu.com/u/114bbbfb977f/2017/04/14/Android 开发最佳实践/","excerpt":"","text":"从Futurice公司Android开发者中学到的经验。遵循以下准则，避免重复发明轮子。若您对开发iOS或Windows Phone 有兴趣，请看iOS Good Practices 和 Windows client Good Practices 这两篇文章。 摘要 使用 Gradle 和它推荐的工程结构 把密码和敏感数据放在gradle.properties 不要自己写 HTTP 客户端,使用Volley或OkHttp库 使用Jackson库解析JSON数据 避免使用Guava同时使用一些类库来避免65k method limit（一个Android程序中最多能执行65536个方法） 使用 Fragments来呈现UI视图 使用 Activities 只是为了管理 Fragments Layout 布局是 XMLs代码，组织好它们 在layoutout XMLs布局时，使用styles文件来避免使用重复的属性 使用多个style文件来避免单一的一个大style文件 保持你的colors.xml 简短DRY(不要重复自己)，只是定义调色板 总是使用dimens.xml DRY(不要重复自己)，定义通用常数 不要做一个深层次的ViewGroup 在使用WebViews时避免在客户端做处理，当心内存泄露 使用Robolectric单元测试，Robotium 做UI测试 使用Genymotion 作为你的模拟器 总是使用ProGuard 和 DexGuard混淆来项目 Android SDK将你的Android SDK放在你的home目录或其他应用程序无关的位置。当安装有些包含SDK的IDE的时候，可能会将SDK放在IDE同一目录下，当你需要升级（或重新安装）IDE或更换的IDE时，会非常麻烦。此外，若果你的IDE是在普通用户，不是在root下运行，还要避免吧SDK放到一下需要sudo权限的系统级别目录下。 构建系统你的默认编译环境应该是Gradle.Ant 有很多限制，也很冗余。使用Gradle，完成以下工作很方便： 构建APP不同版本的变种 制作简单类似脚本的任务 管理和下载依赖 自定义秘钥 更多 同时，Android Gradle插件作为新标准的构建系统正在被Google积极的开发。 工程结构有两种流行的结构：老的Ant &amp; Eclipse ADT 工程结构，和新的Gradle &amp; Android Studio 工程结构，你应该选择新的工程结构，如果你的工程还在使用老的结构，考虑放弃吧，将工程移植到新的结构。 老的结构: 12345678910old-structure├─ assets├─ libs├─ res├─ src│ └─ com/futurice/project├─ AndroidManifest.xml├─ build.gradle├─ project.properties└─ proguard-rules.pro 新的结构 1234567891011121314151617new-structure├─ library-foobar├─ app│ ├─ libs│ ├─ src│ │ ├─ androidTest│ │ │ └─ java│ │ │ └─ com/futurice/project│ │ └─ main│ │ ├─ java│ │ │ └─ com/futurice/project│ │ ├─ res│ │ └─ AndroidManifest.xml│ ├─ build.gradle│ └─ proguard-rules.pro├─ build.gradle└─ settings.gradle 主要的区别在于，新的结构明确的分开了’source sets’ (main,androidTest)，Gradle的一个理念。你可以做到，例如，添加源组‘paid’和‘free’在src中，这将成为您的应用程序的付费和免费的两种模式的源代码。 你的项目引用第三方项目库时（例如，library-foobar），拥有一个顶级包名app从第三方库项目区分你的应用程序是非常有用的。然后settings.gradle不断引用这些库项目，其中app/build.gradle可以引用。 Gradle 配置常用结构 参考Google’s guide on Gradle for Android 小任务 除了(shell, Python, Perl, etc)这些脚本语言，你也可以使用Gradle 制作任务。更多信息请参考Gradle’s documentation。 密码 在做版本release时你app的 build.gradle你需要定义 signingConfigs.此时你应该避免以下内容： 不要做这个 . 这会出现在版本控制中。 12345678signingConfigs &#123; release &#123; storeFile file(\"myapp.keystore\") storePassword \"password123\" keyAlias \"thekey\" keyPassword \"password789\" &#125;&#125; 而是，建立一个不加入版本控制系统的gradle.properties文件。 12KEYSTORE_PASSWORD=password123KEY_PASSWORD=password789 那个文件是gradle自动引入的，你可以在buld.gradle文件中使用，例如： 12345678910111213signingConfigs &#123; release &#123; try &#123; storeFile file(\"myapp.keystore\") storePassword KEYSTORE_PASSWORD keyAlias \"thekey\" keyPassword KEY_PASSWORD &#125; catch (ex) &#123; throw new InvalidUserDataException(\"You should define KEYSTORE_PASSWORD and KEY_PASSWORD in gradle.properties.\") &#125; &#125;&#125; 使用 Maven 依赖方案代替使用导入jar包方案 如果在你的项目中你明确使用率jar文件，那么它们可能成为永久的版本，如2.1.1.下载jar包更新他们是很繁琐的，这个问题Maven很好的解决了，这在Android Gradle构建中也是推荐的方法。你可以指定版本的一个范围，如2.1.+,然后Maven会自动升级到制定的最新版本，例如： 123456789dependencies &#123; compile 'com.netflix.rxjava:rxjava-core:0.19.+' compile 'com.netflix.rxjava:rxjava-android:0.19.+' compile 'com.fasterxml.jackson.core:jackson-databind:2.4.+' compile 'com.fasterxml.jackson.core:jackson-core:2.4.+' compile 'com.fasterxml.jackson.core:jackson-annotations:2.4.+' compile 'com.squareup.okhttp:okhttp:2.0.+' compile 'com.squareup.okhttp:okhttp-urlconnection:2.0.+'&#125; IDEs and text editorsIDE集成开发环境和文本编辑器无论使用什么编辑器，一定要构建一个良好的工程结构 编辑器每个人都有自己的选择，让你的编辑器根据工程结构和构建系统运作，那是你自己的责任。 当下首推Android Studio,因为他是由谷歌开发，最接近Gradle，默认使用最新的工程结构，已经到beta阶段（目前已经有release 1.0了），它就是为Android开发定制的。 你也可以使用Eclipse ADT ，但是你需要对它进行配置，因为它使用了旧的工程结构和Ant作为构建系统。你甚至可以使用纯文版编辑器如Vim，Sublime Text，或者Emacs。如果那样的话，你需要使用Gardle和adb命令行。如果使用Eclipse集成Gradle不适合你，你只是使用命令行构建工程，或迁移到Android Studio中来吧。 无论你使用何种开发工具，只要确保Gradle和新的项目结构保持官方的方式构建应用程序，避免你的编辑器配置文件加入到版本控制。例如，避免加入Ant build.xml文件。特别如果你改变Ant的配置，不要忘记保持build.gradle是最新和起作用的。同时，善待其他开发者，不要强制改变他们的开发工具和偏好。 类库Jackson 是一个将java对象转换成JSON与JSON转化java类的类库。Gson是解决这个问题的流行方案，然而我们发现Jackson更高效,因为它支持替代的方法处理JSON:流、内存树模型,和传统JSON-POJO数据绑定。不过，请记住，Jsonkson库比起GSON更大，所以根据你的情况选择，你可能选择GSON来避免APP 65k个方法限制。其它选择: Json-smart and Boon JSON 网络请求，缓存，图片 执行请求后端服务器，有几种交互的解决方案，你应该考虑实现你自己的网络客户端。使用 Volley或Retrofit。Volley 同时提供图片缓存类。若果你选择使用Retrofit,那么考虑使用Picasso来加载图片和缓存，同时使用OkHttp作为高效的网络请求。Retrofit，Picasso和OkHttp都是有同一家公司开发（注：是由Square 公司开发），所以它们能很好的在一起运行。OkHttp 同样可以和Volley在一起使用 Volley. RxJava 是函数式反应性的一个类库，换句话说，能处理异步的事件。这是一个强大的和有前途的模式，同时也可能会造成混淆，因为它是如此的不同。我们建议在使用这个库架构整个应用程序之前要谨慎考虑。有一些项目是使用RxJava完成的，如果你需要帮助可以跟这些人取得联系：Timo Tuominen, Olli Salonen, Andre Medeiros, Mark Voit, Antti Lammi, Vera Izrailit, Juha Ristolainen.我们也写了一些博客：[1], [2],[3],[4]. 如若你之前有使用过Rx的经历，开始从API响应应用它。另外，从简单的UI事件处理开始运用，如单击事件或在搜索栏输入事件。若对你的Rx技术有信心，同时想要将它应用到你的整体架构中，那么请在复杂的部分写好Javadocs文档。请记住其他不熟悉RxJava的开发人员，可能会非常难理解整个项目。尽你的的全力帮助他们理解你的代码和Rx。 Retrolambda 是一个在Android和预JDK8平台上的使用Lambda表达式语法的Java类库。它有助于保持你代码的紧凑性和可读性，特别当你使用如RxJava函数风格编程时。使用它时先安装JDK8，在Android Studio工程结构对话框中把它设置成为SDK路径，同时设置JAVA8_HOME和JAVA7_HOME环境变量，然后在工程根目录下配置 build.gradle： 123dependencies &#123; classpath 'me.tatarka:gradle-retrolambda:2.4.+'&#125; 同时在每个module 的build.gradle中添加 12345678910111213apply plugin: 'retrolambda'android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8&#125;retrolambda &#123; jdk System.getenv(\"JAVA8_HOME\") oldJdk System.getenv(\"JAVA7_HOME\") javaVersion JavaVersion.VERSION_1_7&#125; Android Studio 提供Java8 lambdas表带是代码提示支持。如果你对lambdas不熟悉，只需参照以下开始学习吧： 任何只包含一个接口的方法都是”lambda friendly”同时代码可以被折叠成更紧凑的语法 如果对参数或类似有疑问，就写一个普通的匿名内部类，然后让Android Status为你生成一个lambda。 当心dex方法数限制，同时避免使用过多的类库 Android apps，当打包成一个dex文件时，有一个65535个应用方法强硬限制[1] [2] [3]。当你突破65k限制之后你会看到一个致命错误。因此，使用一个正常范围的类库文件，同时使用dex-method-counts工具来决定哪些类库可以再65k限制之下使用，特别的避免使用Guava类库，因为它包含超过13k个方法。 Activities and FragmentsFragments应该作为你实现UI界面默认选择。你可以重复使用Fragments用户接口来组合成你的应用。我们强烈推荐使用Fragments而不是activity来呈现UI界面，理由如下： 提供多窗格布局解决方案 Fragments 的引入主要将手机应用延伸到平板电脑，所以在平板电脑上你可能有A、B两个窗格，但是在手机应用上A、B可能分别充满整个屏幕。如果你的应用在最初就使用了fragments，那么以后将你的应用适配到其他不同尺寸屏幕就会非常简单。 屏幕间数据通信 从一个Activity发送复杂数据(例如Java对象)到另外一个Activity，Android的API并没有提供合适的方法。不过使用Fragment，你可以使用一个activity实例作为这个activity子fragments的通信通道。即使这样比Activity与Activity间的通信好，你也想考虑使用Event Bus架构，使用如Otto 或者 greenrobot EventBus作为更简洁的实现。如果你希望避免添加另外一个类库，RxJava同样可以实现一个Event Bus。 Fragments 一般通用的不只有UI 你可以有一个没有界面的fragment作为Activity提供后台工作。进一步你可以使用这个特性来创建一个fragment 包含改变其它fragment的逻辑而不是把这个逻辑放在activity中。 甚至ActionBar 都可以使用内部fragment来管理 你可以选择使用一个没有UI界面的fragment来专门管理ActionBar,或者你可以选择使用在每个Fragment中添加它自己的action 来作为父Activity的ActionBar.参考. 很不幸，我们不建议广泛的使用嵌套的fragments，因为有时会引起matryoshka bugs。我们只有当它有意义(例如，在水平滑动的ViewPager在像屏幕一样fragment中)或者他的确是一个明智的选择的时候才广泛的使用fragment。 在一个架构级别，你的APP应该有一个顶级的activity来包含绝大部分业务相关的fragment。你也可能还有一些辅助的activity ，这些辅助的activity与主activity通信很简单限制在这两种方法Intent.setData()) 或 Intent.setAction())或类似的方法。 Java 包结构Android 应用程序在架构上大致是Java中的Model-View-Controller结构。在Android 中 Fragment和Activity通常上是控制器类(http://www.informit.com/articles/article.aspx?p=2126865).换句话说，他们是用户接口的部分，同样也是Views视图的部分。 正是因为如此，才很难严格的将fragments (或者 activities) 严格的划分成 控制器controlloers还是视图 views。最还是将它们放在自己单独的 fragments 包中。只要你遵循之前提到的建议，Activities 则可以放在顶级目录下。若果你规划有2到3个以上的activity，那么还是同样新建一个activities包吧。 然而，这种架构可以看做是另一种形式的MVC，包含要被解析API响应的JSON数据，来填充的POJO的models包中。和一个views包来包含你的自定义视图、通知、导航视图，widgets等等。适配器Adapter是在数据和视图之间。然而他们通常需要通过getView()方法来导出一些视图，所以你可以将adapters包放在views包里面。 一些控制器角色的类是应用程序级别的，同时是接近系统的。这些类放在managers包下面。一些繁杂的数据处理类，比如说”DateUtils”,放在utils包下面。与后端交互负责网络处理类，放在network包下面。 总而言之，以最接近用户而不是最接近后端去安排他们。 1234567891011com.futurice.project├─ network├─ models├─ managers├─ utils├─ fragments└─ views ├─ adapters ├─ actionbar ├─ widgets └─ notifications 资源文件 Resources 命名 遵循前缀表明类型的习惯，形如type_foo_bar.xml。例如：fragment_contact_details.xml,view_primary_button.xml,activity_main.xml. 组织布局文件 若果你不确定如何排版一个布局文件，遵循一下规则可能会有帮助。 每一个属性一行，缩进4个空格 android:id 总是作为第一个属性 android:layout_**** 属性在上边 style 属性在底部 关闭标签/&gt;单独起一行，有助于调整和添加新的属性 考虑使用Designtime attributes 设计时布局属性，Android Studio已经提供支持，而不是硬编码android:text(译者注：墙内也可以参考stormzhang的这篇博客链接)。 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;TextView android:id=\"@+id/name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentRight=\"true\" android:text=\"@string/name\" style=\"@style/FancyText\" /&gt; &lt;include layout=\"@layout/reusable_part\" /&gt;&lt;/LinearLayout&gt; 作为一个经验法则,android:layout_****属性应该在 layout XML 中定义,同时其它属性android:**** 应放在 styler XML中。此规则也有例外，不过大体工作的很好。这个思想整体是保持layout属性(positioning, margin, sizing) 和content属性在布局文件中，同时将所有的外观细节属性（colors, padding, font）放在style文件中。 例外有以下这些: android:id 明显应该在layout文件中 layout文件中android:orientation对于一个LinearLayout布局通常更有意义 android:text 由于是定义内容，应该放在layout文件中 有时候将android:layout_width 和 android:layout_height属性放到一个style中作为一个通用的风格中更有意义，但是默认情况下这些应该放到layout文件中。 使用styles 几乎每个项目都需要适当的使用style文件，因为对于一个视图来说有一个重复的外观是很常见的。在应用中对于大多数文本内容，最起码你应该有一个通用的style文件，例如： 1234&lt;style name=\"ContentText\"&gt; &lt;item name=\"android:textSize\"&gt;@dimen/font_normal&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/basic_black&lt;/item&gt;&lt;/style&gt; 应用到TextView 中: 123456&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/price\" style=\"@style/ContentText\" /&gt; 你或许需要为按钮控件做同样的事情，不要停止在那里。将一组相关的和重复android:****的属性放到一个通用的style中。 将一个大的style文件分割成多个文件 你可以有多个styles.xml 文件。Android SDK支持其它文件，styles这个文件名称并没有作用，起作用的是在文件里xml的&lt;style&gt;标签。因此你可以有多个style文件styles.xml,style_home.xml,style_item_details.xml,styles_forms.xml。不用于资源文件路径需要为系统构建起的有意义，在res/values目录下的文件可以任意命名。 colors.xml是一个调色板 在你的colors.xml文件中应该只是映射颜色的名称一个RGBA值，而没有其它的。不要使用它为不同的按钮来定义RGBA值。 不要这样做 123456789&lt;resources&gt; &lt;color name=\"button_foreground\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"button_background\"&gt;#2A91BD&lt;/color&gt; &lt;color name=\"comment_background_inactive\"&gt;#5F5F5F&lt;/color&gt; &lt;color name=\"comment_background_active\"&gt;#939393&lt;/color&gt; &lt;color name=\"comment_foreground\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"comment_foreground_important\"&gt;#FF9D2F&lt;/color&gt; ... &lt;color name=\"comment_shadow\"&gt;#323232&lt;/color&gt; 使用这种格式，你会非常容易的开始重复定义RGBA值，这使如果需要改变基本色变的很复杂。同时，这些定义是跟一些环境关联起来的，如button或者comment,应该放到一个按钮风格中，而不是在color.xml文件中。 相反，这样做: 12345678910111213141516&lt;resources&gt; &lt;!-- grayscale --&gt; &lt;color name=\"white\" &gt;#FFFFFF&lt;/color&gt; &lt;color name=\"gray_light\"&gt;#DBDBDB&lt;/color&gt; &lt;color name=\"gray\" &gt;#939393&lt;/color&gt; &lt;color name=\"gray_dark\" &gt;#5F5F5F&lt;/color&gt; &lt;color name=\"black\" &gt;#323232&lt;/color&gt; &lt;!-- basic colors --&gt; &lt;color name=\"green\"&gt;#27D34D&lt;/color&gt; &lt;color name=\"blue\"&gt;#2A91BD&lt;/color&gt; &lt;color name=\"orange\"&gt;#FF9D2F&lt;/color&gt; &lt;color name=\"red\"&gt;#FF432F&lt;/color&gt;&lt;/resources&gt; 向应用设计者那里要这个调色板，名称不需要跟”green”, “blue”, 等等相同。“brand_primary”, “brand_secondary”, “brand_negative” 这样的名字也是完全可以接受的。像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。通常一个具有审美价值的UI来说，减少使用颜色的种类是非常重要的。 像对待colors.xml一样对待dimens.xml文件 与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。一个好的例子，如下所示： 123456789101112131415161718192021&lt;resources&gt; &lt;!-- font sizes --&gt; &lt;dimen name=\"font_larger\"&gt;22sp&lt;/dimen&gt; &lt;dimen name=\"font_large\"&gt;18sp&lt;/dimen&gt; &lt;dimen name=\"font_normal\"&gt;15sp&lt;/dimen&gt; &lt;dimen name=\"font_small\"&gt;12sp&lt;/dimen&gt; &lt;!-- typical spacing between two views --&gt; &lt;dimen name=\"spacing_huge\"&gt;40dp&lt;/dimen&gt; &lt;dimen name=\"spacing_large\"&gt;24dp&lt;/dimen&gt; &lt;dimen name=\"spacing_normal\"&gt;14dp&lt;/dimen&gt; &lt;dimen name=\"spacing_small\"&gt;10dp&lt;/dimen&gt; &lt;dimen name=\"spacing_tiny\"&gt;4dp&lt;/dimen&gt; &lt;!-- typical sizes of views --&gt; &lt;dimen name=\"button_height_tall\"&gt;60dp&lt;/dimen&gt; &lt;dimen name=\"button_height_normal\"&gt;40dp&lt;/dimen&gt; &lt;dimen name=\"button_height_short\"&gt;32dp&lt;/dimen&gt;&lt;/resources&gt; 布局时在写 margins 和 paddings 时，你应该使用spacing_****尺寸格式来布局，而不是像对待String字符串一样直接写值。这样写会非常有感觉，会使组织和改变风格或布局是非常容易。 避免深层次的视图结构 有时候为了摆放一个视图，你可能尝试添加另一个LinearLayout。你可能使用这种方法解决： 123456789101112131415161718192021222324252627282930&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;RelativeLayout ... &gt; &lt;LinearLayout ... &gt; &lt;LinearLayout ... &gt; &lt;LinearLayout ... &gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 即使你没有非常明确的在一个layout布局文件中这样使用，如果你在Java文件中从一个view inflate（这个inflate翻译不过去，大家理解就行） 到其他views当中，也是可能会发生的。 可能会导致一系列的问题。你可能会遇到性能问题，因为处理起需要处理一个复杂的UI树结构。还可能会导致以下更严重的问题StackOverflowError. 因此尽量保持你的视图tree：学习如何使用RelativeLayout,如何 optimize 你的布局 和如何使用&lt;merge&gt; 标签. 小心关于WebViews的问题. 如果你必须显示一个web视图，比如说对于一个新闻文章，避免做客户端处理HTML的工作，最好让后端工程师协助，让他返回一个 “纯“ HTML。WebViews 也能导致内存泄露当保持引他们的Activity，而不是被绑定到ApplicationContext中的时候。当使用简单的文字或按钮时，避免使用WebView，这时使用TextView或Buttons更好。 测试框架Android SDK的测试框架还处于初级阶段，特别是关于UI测试方面。Android Gradle目前实现了一个叫connectedAndroidTest的测试，它使用一个JUnit 为Android提供的扩展插件 extension of JUnit with helpers for Android.可以跑你生成的JUnit测试， 只当做单元测试时使用 Robolectric ，views 不用它是一个最求提供”不连接设备的”为了加速开发的测试，非常时候做 models 和 view models 的单元测试。然而，使用Robolectric测试时不精确的，也不完全对UI测试。当你对有关动画的UI元素、对话框等，测试时会有问题，这主要是因为你是在 “在黑暗中工作”（在没有可控的界面情况下测试） Robotium 使写UI测试非常简单。 对于UI测试你不需 Robotium 跑与设备连接的测试。但它可能会对你有益，是因为它有许多来帮助类的获得和分析视图，控制屏幕。测试用例看起来像这样简单： 12345solo.sendKey(Solo.MENU);solo.clickOnText(\"More\"); // searches for the first occurence of \"More\" and clicks on itsolo.clickOnText(\"Preferences\");solo.clickOnText(\"Edit File Extensions\");Assert.assertTrue(solo.searchText(\"rtf\")); 模拟器如果你全职开发Android App,那么买一个Genymotion emulatorlicense吧。Genymotion 模拟器运行更快的秒帧的速度，比起典型的AVD模拟器。他有演示你APP的工具，高质量的模拟网络连接，GPS位置，等等。它同时还有理想的连接测试。你若涉及适配使用很多不同的设备，买一个Genymotion 版权是比你买很多真设备便宜多的。 注意：Genymotion模拟器没有装载所有的Google服务，如Google Play Store和Maps。你也可能需要测试Samsung指定的API，若这样的话你还是需要购买一个真实的Samsung设备。 混淆配置ProGuard 是一个在Android项目中广泛使用的压缩和混淆打包的源码的工具。 你是否使用ProGuard取决你项目的配置，当你构建一个release版本的apk时，通常你应该配置gradle文件。 12345678910buildTypes &#123; debug &#123; minifyEnabled false &#125; release &#123; signingConfig signingConfigs.release minifyEnabled true proguardFiles 'proguard-rules.pro' &#125;&#125; 为了决定哪些代码应该被保留，哪些代码应该被混淆，你不得不指定一个或多个实体类在你的代码中。这些实体应该是指定的类包含main方法，applets，midlets，activities，等等。Android framework 使用一个默认的配置文件，可以在SDK_HOME/tools/proguard/proguard-android.txt目录下找到。自定义的工程指定的 project-specific 混淆规则，如在my-project/app/proguard-rules.pro中定义，会被添加到默认的配置中。 关于 ProGuard 一个普遍的问题，是看应用程序是否崩溃并报ClassNotFoundException 或者 NoSuchFieldException 或类似的异常，即使编译是没有警告并运行成功。这意味着以下两种可能： ProGuard 已经移除了类，枚举，方法，成员变量或注解，考虑是否是必要的。 ProGuard 混淆了类，枚举，成员变量的名称，但是这些名字又被拿原始名称使用了，比如通过Java的反射。 检查app/build/outputs/proguard/release/usage.txt文件看有问题的对象是否被移除了。检查 app/build/outputs/proguard/release/mapping.txt 文件看有问题的对象是否被混淆了。 In order to prevent ProGuard from stripping away needed classes or class members, add a keep options to your proguard config:以防 ProGuard 剥离 需要的类和类成员，添加一个 keep选项在你的 proguard 配置文件中：1-keep class com.futurice.project.MyClass &#123; *; &#125; 防止 ProGuard 混淆 一些类和成员，添加 keepnames:1-keepnames class com.futurice.project.MyClass &#123; *; &#125; 查看this template’s ProGuard config 中的一些例子。更多例子请参考Proguard。 在构建项目之初，发布一个版本 来检查ProGuard规则是否正确的保持了重要的部分。同时无论何时你添加了新的类库，做一个发布版本，同时apk在设备上跑起来测试一下。不要等到你的app要发布 “1.0”版本了才做版本发布，那时候你可能会碰到好多意想不到的异常，需要一些时间去修复他们。 Tips每次发布新版本都要写 mapping.txt。每发布一个版本，如果用户遇到一个bug，同时提交了一个混淆过的堆栈跟踪。通过保留mapping.txt文件，来确定你可以调试的问题。 DexGuard 若果你需要核心工具来优化，和专门混淆的发布代码，考虑使用DexGuard,一个商业软件，ProGuard 也是有他们团队开发的。它会很容易将Dex文件分割，来解决65K个方法限制问题。 致谢感谢Antti Lammi, Joni Karppinen, Peter Tackage, Timo Tuominen, Vera Izrailit, Vihtori Mäntylä, Mark Voit, Andre Medeiros, Paul Houghton 这些人和Futurice 开发者分享他们的Android开发经验。 LicenseFuturice OyCreative Commons Attribution 4.0 International (CC BY 4.0) TranslationTranslated to Chinese by andyiac ####本文为转载，原文地址","categories":[],"tags":[]}]}